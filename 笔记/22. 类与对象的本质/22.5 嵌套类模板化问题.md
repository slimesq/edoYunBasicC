#### 一、嵌套类的模块化问题

##### 1. 定义嵌套类

- **基本形式**：在类内部定义另一个类，如Role类中包含Skill类
- **常规写法**：嵌套类通常直接写在主类内部，不会产生问题
- **使用场景**：嵌套类在实际开发中使用频率较低，但特定场景下需要模块化时会遇到特殊问题

##### 2. 模块化问题 

###### 1）典型错误

- 模块化常规做法：
  - 创建Role.h声明主类
  
    ```c++
    #pragma once
    #include "Skill.h"
    
    class Role
    {
    public:
    	class Skill;
    };
    
    ```
  
  - 创建Skill.h声明嵌套类
  
    ```c++
    #pragma once
    #include "Role.h"
    class Role::Skill
    {
    public:
    	int hp;
    	int mp;
    };
    ```
  
  - **错误写法**：在Role.h中包含#include "Skill.h",会出现如下代码：声名Role::Skill找不到Role
  
  ```c++
  class Role::Skill
  {
  public:
  	int hp;
  	int mp;
  };
  
  class Role
  {
  public:
  	class Skill;
  };
  ```

- 错误本质：先有鸡还是先有蛋的问题，当Skill.h包含Role.h时，Role尚未定义

###### 2）问题解决

- 例题:类嵌套类模块化问题
  - **解决原则**：避免头文件相互包含
  - **正确做法**:
    - Role.h中只做前向声明class Skill;
    
      ```C++
      #pragma once
      //#include "Skill.h"
      
      class Role
      {
      public:
      	class Skill;
      };
      ```
  - **关键点**：理解编译器处理头文件的顺序，确保类型定义在使用前可见。

